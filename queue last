package newproject; 

import javax.swing.*;
import java.awt.*;
import java.awt.geom.Arc2D;
import java.awt.geom.Area;
import java.util.ArrayList;
import javax.swing.border.EmptyBorder;
import java.awt.geom.AffineTransform;

/* ------------------ Select Queue  ------------------ */
public class Queue {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Queue Selector");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(550, 750);
            frame.setLayout(new BorderLayout());
            frame.setResizable(false);

            // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Singly ‡∏´‡∏£‡∏∑‡∏≠ Doubly
            String[] options = {"Singly Circular Queue", "Doubly Circular Queue"};
            String choice = (String) JOptionPane.showInputDialog(
                    frame,
                    "CIRCULAR QUEUE :",
                    "Queue Selector",
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    options,
                    options[0]
            );

            if (choice == null) {
                System.exit(0); // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏î Cancel ‡∏≠‡∏≠‡∏Å‡πÄ‡∏•‡∏¢
            }

            if ("Singly Circular Queue".equals(choice)) {
                SinglyCircularQueueUI singlyQueuePanel = new SinglyCircularQueueUI();
                frame.add(singlyQueuePanel, BorderLayout.CENTER);
            } else if ("Doubly Circular Queue".equals(choice)) {
                DoublyCircularQueueUI doublyQueuePanel = new DoublyCircularQueueUI();
                frame.add(doublyQueuePanel, BorderLayout.CENTER);
            }

            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }
}

/* ------------------ Circle Panel ------------------ */
class Circle extends JPanel {
    // Queue size
    public static final int SIZE = 8; // ‡∏≠‡∏¢‡∏≤‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ñ‡∏¥‡∏ß‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡∏Ñ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≤

    private final int numSegments = SIZE;
    private final String[] values;
    private int count = 0;
    private int front = -1;
    private int rear = -1;

    private final Color[] sectorColors;
    private final Color defaultColor = Color.decode("#C0BFC0");
    private final Color filledColor = Color.decode("#6a696a");
    
    public Circle(String[] values) {
        this.values = values;
        this.sectorColors = new Color[values.length];
        for (int i = 0; i < sectorColors.length; i++) {
            sectorColors[i] = defaultColor;
        }
    }

    public void setCount(int count) {
        this.count = count;
        repaint();
    }

    public void setFrontRear(int f ,int r){
        this.front = f;
        this.rear = r;
        repaint();
    }

    public void setSectorColor(int index, boolean isFilled) {
        if (index >= 0 && index < sectorColors.length) {
            sectorColors[index] = isFilled ? filledColor : defaultColor;
            repaint();
        }
    }

    // ‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏≠‡∏ö‡πÜ ‡πÉ‡∏´‡πâ‡∏°‡∏±‡∏ô‡πÄ‡∏ó‡πà‡πÄ‡∏â‡∏¢‡πÜ
    private void drawCurvedText(Graphics2D g2d, String text, int centerX, int centerY, int radius, double angleRad, Color color) {
        g2d.setColor(color);
        FontMetrics fm = g2d.getFontMetrics();

        double textWidth = 0;
        for (char c : text.toCharArray()) {
            textWidth += fm.charWidth(c);

        }

        double totalAngle = textWidth / (double) radius;
        double startAngle = angleRad - totalAngle / 2;

        AffineTransform old = g2d.getTransform();

        for (char c : text.toCharArray()) {
            int cw = fm.charWidth(c);
            double charAngle = cw / (double) radius / 2.0;

            startAngle += charAngle;
            double x = centerX + radius * Math.cos(startAngle);
            double y = centerY - radius * Math.sin(startAngle);
            g2d.translate(x, y);
            g2d.rotate(-startAngle - Math.PI / 2);
            g2d.drawString(String.valueOf(c), -cw / 2, 0);
            g2d.setTransform(old);
            startAngle += charAngle;

        }
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á donut ‡πÇ‡∏Ñ‡∏ï‡∏£‡∏à‡∏∞‡πÄ‡∏à‡πã‡∏á üëç
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        setBackground(Color.decode("#F5F5F5")); 

        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int width = getWidth();
        int height = getHeight();
        int centerX = width / 2;
        int centerY = height / 2;

        int outerRadius = 170;
        int innerRadius = 100;

        double angleStep = 360.0 / numSegments;

        for (int i = 0; i < numSegments; i++) {
            double startAngle = i * angleStep;

            Arc2D outer = new Arc2D.Double(
                    centerX - outerRadius, centerY - outerRadius,
                    outerRadius * 2, outerRadius * 2,
                    startAngle, angleStep, Arc2D.PIE
            );

            Arc2D inner = new Arc2D.Double(
                    centerX - innerRadius, centerY - innerRadius,
                    innerRadius * 2, innerRadius * 2,
                    startAngle, angleStep, Arc2D.PIE
            );

            Area sector = new Area(outer);
            sector.subtract(new Area(inner));

            // ‡∏™‡∏µ‡πÇ‡∏î‡∏ô‡∏±‡∏ó
            g2d.setColor(sectorColors[i]);
            g2d.fill(sector);

            // ‡∏™‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ sector
            g2d.setStroke(new BasicStroke(2));
            g2d.setColor(Color.decode("#F5F5F5"));
            g2d.draw(sector);

            // Label
            double midAngle = Math.toRadians(startAngle + angleStep / 2);
            int labelRadius = (outerRadius + innerRadius) / 2;
            int labelX = (int) (centerX + labelRadius * Math.cos(midAngle));
            int labelY = (int) (centerY - labelRadius * Math.sin(midAngle));

            // text enqueue in donut
            g2d.setColor(Color.decode("#F5F5F5"));
            g2d.setFont(new Font("Arial", Font.BOLD, 16));
            String label = values[i] == null ? "" : values[i];
            FontMetrics fm = g2d.getFontMetrics();
            int labelWidth = fm.stringWidth(label);
            int labelHeight = fm.getAscent();
            g2d.drawString(label, labelX - labelWidth / 2, labelY + labelHeight / 2);

            // number orbit
            int numOrbit = outerRadius + 10;
            int numX = (int) (centerX + numOrbit * Math.cos(midAngle));
            int numY = (int) (centerY - numOrbit * Math.sin(midAngle));
            g2d.setFont(new Font("Arial", Font.BOLD, 16));
            g2d.setColor(sectorColors[i]);
            String numLabel = String.valueOf(i);
            int numW = fm.stringWidth(numLabel);
            int numH = fm.getAscent();
            g2d.drawString(numLabel, numX - numW / 2, numY + numH / 2);

            // string orbit
            int strOrbit = outerRadius + -75;
            if (i == front && i == rear) {
                strOrbit = outerRadius + -95;
                drawCurvedText(g2d, "REAR >", centerX, centerY, strOrbit, midAngle, Color.decode("#FFBD44"));
                strOrbit = outerRadius + -75;
                drawCurvedText(g2d, "< FRONT", centerX, centerY, strOrbit, midAngle, Color.decode("#FFBD44"));
                
            } else if (i == front) {
                drawCurvedText(g2d, "< FRONT", centerX, centerY, strOrbit, midAngle, Color.decode("#FF605C"));

            } else if (i == rear) {
                drawCurvedText(g2d, "REAR >", centerX, centerY, strOrbit, midAngle, Color.decode("#00CA4E"));

            }

            // count ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
            g2d.setColor(Color.decode("#6a696a"));
            Font numFont = new Font("Arial", Font.BOLD, 16);
            g2d.setFont(numFont);
            String numLa = String.valueOf(count);
            FontMetrics numFm = g2d.getFontMetrics();
            int numCW = numFm.stringWidth(numLa);
            int lineHeight = numFm.getHeight();
            g2d.drawString(numLa, centerX - numCW / 2, centerY - lineHeight / 4);

            Font labelFont = new Font("Arial", Font.BOLD, 10);
            g2d.setFont(labelFont);
            String cLa = "Element in queue";
            FontMetrics labelFm = g2d.getFontMetrics();
            int laCW = labelFm.stringWidth(cLa);
            g2d.drawString(cLa, centerX - laCW / 2, centerY + lineHeight);

        }
    }
}

/* ------------------ Singly Circular Queue ------------------ */
class SinglyCircularQueueUI extends JPanel {
    private final String[] values = new String[Circle.SIZE];
    private final int SIZE = Circle.SIZE;

    private int count = 0;
    private int front = -1, rear = -1;
    private final ArrayList<String> dequeuedList = new ArrayList<>();   // ‡πÉ‡∏ä‡πâ‡πÉ‡∏ôhistory ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    private final Circle circlePanel;

    public SinglyCircularQueueUI() {
        setLayout(new BorderLayout());
        setBackground(Color.decode("#F5F5F5")); 

        JLabel label = new JLabel("Singly Circular Queue", JLabel.CENTER);
        label.setFont(new Font("Monospaced", Font.BOLD, 30));
        label.setBorder(new EmptyBorder(30,0,0,0));
        add(label, BorderLayout.NORTH);

        circlePanel = new Circle(values);
        circlePanel.setCount(count); 
        add(circlePanel, BorderLayout.CENTER);

        JPanel southPanel = new JPanel();
        southPanel.setLayout(new BoxLayout(southPanel, BoxLayout.Y_AXIS));
        southPanel.setBorder(new EmptyBorder(0, 0, 50, 0));

        // input
        JTextField tf = new JTextField();
        tf.setFont(new Font("DialogInput", Font.BOLD, 20));
        tf.setMaximumSize(new Dimension(180, 20));
        tf.setAlignmentX(Component.CENTER_ALIGNMENT);
        tf.setHorizontalAlignment(JTextField.CENTER);
        southPanel.add(tf);

        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // ‡∏õ‡∏∏‡πà‡∏°
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        JButton enqueueBtn = new JButton("Enqueue");
        JButton dequeueBtn = new JButton("Dequeue");
        buttonPanel.add(enqueueBtn);
        buttonPanel.add(dequeueBtn);

        JPanel buttonPane2 = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        JButton showBtn = new JButton("Review Dequeued");
        buttonPane2.add(showBtn);

        JPanel buttonPane3 = new JPanel(new FlowLayout(FlowLayout.RIGHT, 75, 0));
        JButton backhome = new JButton("back");
        buttonPane3.add(backhome);

        southPanel.add(buttonPanel);
        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        southPanel.add(buttonPane2);
        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        southPanel.add(buttonPane3);
        add(southPanel, BorderLayout.SOUTH);

        // Actions
        enqueueBtn.addActionListener(_ -> { //‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° 
            String text = tf.getText().trim(); //‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å textfield
            if (!text.isEmpty()) { //‡∏ñ‡πâ‡∏≤textfield ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤
                enqueue(text); 
                tf.setText("");
                repaint(); // ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä donut
            }
            tf.requestFocusInWindow(); //‡πÄ‡∏Ñ‡∏≠‡∏≠‡∏£‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà textfield ‡∏ï‡∏•‡∏≠‡∏î

        });

        dequeueBtn.addActionListener(_ -> {
            String val = dequeue();
            if (val != null) { //‡∏ñ‡πâ‡∏≤ dequeue ‡πÑ‡∏î‡πâ‡∏Ñ‡πà‡∏≤
                dequeuedList.add(val);
                repaint();
            }
        });

        showBtn.addActionListener(_ -> {
            JOptionPane.showMessageDialog(this, "Dequeued values: " + dequeuedList); //history
        });
        
        backhome.addActionListener(_ -> {
            JFrame topFrame = (JFrame) SwingUtilities.getWindowAncestor(this); //‡∏Ñ‡∏ô‡∏´‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            topFrame.dispose(); //‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            Queue.main(null); //‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏£‡∏Å
        });

    }

        private boolean isFull() {
        return (front == 0 && rear == SIZE - 1) || (rear + 1) % SIZE == front;
    }

    private boolean isEmpty() {
        return (front == -1 && rear == -1);
    }

    private void enqueue(String val) {
        if (isFull()) {
            JOptionPane.showMessageDialog(this, "Queue is full!");
            return;
        }
        if (isEmpty()) { //‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ô‡∏Ñ‡∏¥‡∏ß
            front = rear = 0;
        } else {
            rear = (rear + 1) % SIZE; // ‡∏î‡∏±‡∏ô rear ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
        }
        values[rear] = val;
        count++; 
        circlePanel.setSectorColor(rear, true);
        circlePanel.setFrontRear(front,rear);
        circlePanel.setCount(count);
    }

    private String dequeue() {
        if (isEmpty()) {
            JOptionPane.showMessageDialog(this, "Queue is empty!");
            return null;
        }

        int oldFront = front; // ‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á front ‡πÄ‡∏Å‡πà‡∏≤‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö

        String val = values[front];
        values[front] = null;
        if (front == rear) {
            front = rear = -1;
        } else {
            front = (front + 1) % SIZE; // ‡∏î‡∏±‡∏ô front ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
        }
        count--;
        circlePanel.setSectorColor(oldFront, false); 
        circlePanel.setFrontRear(front,rear);
        circlePanel.setCount(count);

        return val;
    }
}

/* ------------------ Doubly Circular Queue ------------------ */
class DoublyCircularQueueUI extends JPanel {
    private final String[] values = new String[Circle.SIZE];
    private final int SIZE = Circle.SIZE;

    private int count = 0;
    private int front = -1, rear = -1;
    private final ArrayList<String> dequeuedList = new ArrayList<>();
    private final Circle circlePanel;

    public DoublyCircularQueueUI() {
        setLayout(new BorderLayout());
        setBackground(Color.decode("#F5F5F5")); 

        JLabel label = new JLabel("Doubly Circular Queue", JLabel.CENTER);
        label.setFont(new Font("Monospaced", Font.BOLD, 30));
        label.setBorder(new EmptyBorder(30,0,0,0));
        add(label, BorderLayout.NORTH);

        circlePanel = new Circle(values);
        circlePanel.setCount(count); 
        add(circlePanel, BorderLayout.CENTER);

        JPanel southPanel = new JPanel();
        southPanel.setLayout(new BoxLayout(southPanel, BoxLayout.Y_AXIS));
        southPanel.setBorder(new EmptyBorder(0, 0, 35, 0));
        
        // input
        JTextField tf = new JTextField();
        tf.setFont(new Font("DialogInput", Font.BOLD, 20));
        tf.setMaximumSize(new Dimension(240, 20));
        tf.setAlignmentX(Component.CENTER_ALIGNMENT);
        tf.setHorizontalAlignment(JTextField.CENTER);
        southPanel.add(tf);

        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // ‡∏õ‡∏∏‡πà‡∏°
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        JButton enqueueFrontBtn = new JButton("Enqueue Front");
        JButton enqueueRearBtn = new JButton("Enqueue Rear");
        buttonPanel.add(enqueueFrontBtn);
        buttonPanel.add(enqueueRearBtn);

        JPanel buttonPane2 = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        JButton dequeueFrontBtn = new JButton("Dequeue Front");
        JButton dequeueRearBtn = new JButton("Dequeue Rear");
        buttonPane2.add(dequeueFrontBtn);
        buttonPane2.add(dequeueRearBtn);

        JPanel buttonPane3 = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        JButton showBtn = new JButton("Review Dequeued");
        buttonPane3.add(showBtn);

        JPanel buttonPane4 = new JPanel(new FlowLayout(FlowLayout.RIGHT, 75, 0));
        JButton backhome = new JButton("back");
        buttonPane4.add(backhome);

        southPanel.add(buttonPanel);
        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        southPanel.add(buttonPane2);
        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        southPanel.add(buttonPane3);
        southPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        southPanel.add(buttonPane4);
        add(southPanel, BorderLayout.SOUTH);

        // Actions
        enqueueFrontBtn.addActionListener(_ -> {
            String text = tf.getText().trim();
            if (!text.isEmpty()) {
                enqueueFront(text);
                tf.setText("");
                circlePanel.setFrontRear(front,rear);
                repaint();
            }
            tf.requestFocusInWindow();

        });

        enqueueRearBtn.addActionListener(_ -> {
            String text = tf.getText().trim();
            if (!text.isEmpty()) {
                enqueueRear(text);
                tf.setText("");
                circlePanel.setFrontRear(front,rear);
                repaint();
            }
            tf.requestFocusInWindow();

        });

        dequeueFrontBtn.addActionListener(_ -> {
            String val = dequeueFront();
            if (val != null) {
                dequeuedList.add(val);
                circlePanel.setFrontRear(front,rear);
                repaint();
            }
        });

        dequeueRearBtn.addActionListener(_ -> {
            String val = dequeueRear();
            if (val != null) {
                dequeuedList.add(val);
                circlePanel.setFrontRear(front,rear);
                repaint();
            }
        });

        showBtn.addActionListener(_ -> {
            JOptionPane.showMessageDialog(this, "Dequeued values: " + dequeuedList);
        });

        backhome.addActionListener(_ -> {
            JFrame topFrame = (JFrame) SwingUtilities.getWindowAncestor(this);
            topFrame.dispose();
            Queue.main(null);
        });

    }

    private boolean isFull() {
        return (front == 0 && rear == SIZE - 1) || (rear + 1) % SIZE == front; //‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡∏¥‡∏ß‡πÄ‡∏ï‡πá‡∏°
    }

    private boolean isEmpty() {
        return (front == -1 && rear == -1); //‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ñ‡∏¥‡∏ß‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤
    }

    private void enqueueFront(String val) {
        if (isFull()) {
            JOptionPane.showMessageDialog(this, "Queue is full!");
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            front = (front - 1 + SIZE) % SIZE; // ‡∏î‡∏±‡∏ô front ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á
        }
        values[front] = val;
        count++;
        circlePanel.setSectorColor(front, true);
        circlePanel.setCount(count);
    }

    private void enqueueRear(String val) {
        if (isFull()) {
            JOptionPane.showMessageDialog(this, "Queue is full!");
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear = (rear + 1) % SIZE;  // ‡∏î‡∏±‡∏ô rear ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
        }
        values[rear] = val;
        count++; 
        circlePanel.setSectorColor(rear, true);
        circlePanel.setCount(count);
    }

    private String dequeueFront() {
        if (isEmpty()) {
            JOptionPane.showMessageDialog(this, "Queue is empty!");
            return null;
        }

        int oldFront = front; 

        String val = values[front];
        values[front] = null;
        if (front == rear) { // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡∏¥‡∏ß‡∏ñ‡πâ‡∏≤‡∏•‡∏ö‡∏´‡∏°‡∏î
            front = rear = -1;
        } else {
            front = (front + 1) % SIZE; // ‡∏î‡∏±‡∏ô front ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
        }
        count--;
        circlePanel.setSectorColor(oldFront, false);
        circlePanel.setCount(count);

        return val;
    }

    private String dequeueRear() {
        if (isEmpty()) {
            JOptionPane.showMessageDialog(this, "Queue is empty!");
            return null;
        }

        int oldRear = rear;

        String val = values[rear];
        values[rear] = null;
        if (front == rear) {
            front = rear = -1;
        } else {
            rear = (rear - 1 + SIZE) % SIZE; // ‡∏î‡∏±‡∏ô rear ‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á
        }
        count--;
        circlePanel.setSectorColor(oldRear, false);
        circlePanel.setCount(count);

        return val;
    }

}
